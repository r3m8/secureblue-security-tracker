{
  "description": "In the Linux kernel, the following vulnerability has been resolved:  9p: set req refcount to zero to avoid uninitialized usage  When a new request is allocated, the refcount will be zero if it is reused, but if the request is newly allocated from slab, it is not fully initialized before being added to idr.  If the p9_read_work got a response before the refcount initiated. It will use a uninitialized req, which will result in a bad request data struct.  Here is the logs from syzbot.  Corrupted memory at 0xffff88807eade00b [ 0xff 0x07 0x00 0x00 0x00 0x00 0x00 0x00 . . . . . . . . ] (in kfence-#110):  p9_fcall_fini net/9p/client.c:248 [inline]  p9_req_put net/9p/client.c:396 [inline]  p9_req_put+0x208/0x250 net/9p/client.c:390  p9_client_walk+0x247/0x540 net/9p/client.c:1165  clone_fid fs/9p/fid.h:21 [inline]  v9fs_fid_xattr_set+0xe4/0x2b0 fs/9p/xattr.c:118  v9fs_xattr_set fs/9p/xattr.c:100 [inline]  v9fs_xattr_handler_set+0x6f/0x120 fs/9p/xattr.c:159  __vfs_setxattr+0x119/0x180 fs/xattr.c:182  __vfs_setxattr_noperm+0x129/0x5f0 fs/xattr.c:216  __vfs_setxattr_locked+0x1d3/0x260 fs/xattr.c:277  vfs_setxattr+0x143/0x340 fs/xattr.c:309  setxattr+0x146/0x160 fs/xattr.c:617  path_setxattr+0x197/0x1c0 fs/xattr.c:636  __do_sys_setxattr fs/xattr.c:652 [inline]  __se_sys_setxattr fs/xattr.c:648 [inline]  __ia32_sys_setxattr+0xc0/0x160 fs/xattr.c:648  do_syscall_32_irqs_on arch/x86/entry/common.c:112 [inline]  __do_fast_syscall_32+0x65/0xf0 arch/x86/entry/common.c:178  do_fast_syscall_32+0x33/0x70 arch/x86/entry/common.c:203  entry_SYSENTER_compat_after_hwframe+0x70/0x82  Below is a similar scenario, the scenario in the syzbot log looks more complicated than this one, but this patch can fix it.       T21124                   p9_read_work ======================== second trans ================================= p9_client_walk   p9_client_rpc     p9_client_prepare_req       p9_tag_alloc         req = kmem_cache_alloc(p9_req_cache, GFP_NOFS);         tag = idr_alloc         << preempted >>         req->tc.tag = tag;                             /* req->[refcount/tag] == uninitialized */                             m->rreq = p9_tag_lookup(m->client, m->rc.tag);                               /* increments uninitalized refcount */          refcount_set(&req->refcount, 2);                             /* cb drops one ref */                             p9_client_cb(req)                             /* reader thread drops its ref:                                request is incorrectly freed */                             p9_req_put(req)     /* use after free and ref underflow */     p9_req_put(req)  To fix it, we can initialize the refcount to zero before add to idr.",
  "scope": "local",
  "releases": {
    "bookworm": {
      "status": "resolved",
      "repositories": {
        "bookworm": "6.1.148-1",
        "bookworm-security": "6.1.158-1"
      },
      "fixed_version": "6.1.4-1",
      "urgency": "not yet assigned"
    },
    "bullseye": {
      "status": "open",
      "repositories": {
        "bullseye": "5.10.223-1",
        "bullseye-security": "5.10.244-1"
      },
      "urgency": "not yet assigned"
    },
    "forky": {
      "status": "resolved",
      "repositories": {
        "forky": "6.16.12-2"
      },
      "fixed_version": "6.1.4-1",
      "urgency": "not yet assigned"
    },
    "sid": {
      "status": "resolved",
      "repositories": {
        "sid": "6.17.7-2"
      },
      "fixed_version": "6.1.4-1",
      "urgency": "not yet assigned"
    },
    "trixie": {
      "status": "resolved",
      "repositories": {
        "trixie": "6.12.43-1",
        "trixie-security": "6.12.48-1"
      },
      "fixed_version": "6.1.4-1",
      "urgency": "not yet assigned"
    }
  }
}