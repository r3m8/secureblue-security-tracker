{
  "description": "In the Linux kernel, the following vulnerability has been resolved:  ieee802154/adf7242: defer destroy_workqueue call  There is a possible race condition (use-after-free) like below    (FREE)                     |  (USE)   adf7242_remove             |  adf7242_channel    cancel_delayed_work_sync  |     destroy_workqueue (1)    |   adf7242_cmd_rx                              |    mod_delayed_work (2)                              |  The root cause for this race is that the upper layer (ieee802154) is unaware of this detaching event and the function adf7242_channel can be called without any checks.  To fix this, we can add a flag write at the beginning of adf7242_remove and add flag check in adf7242_channel. Or we can just defer the destructive operation like other commit 3e0588c291d6 (\"hamradio: defer ax25 kfree after unregister_netdev\") which let the ieee802154_unregister_hw() to handle the synchronization. This patch takes the second option.  runs\")",
  "scope": "local",
  "releases": {
    "bookworm": {
      "status": "resolved",
      "repositories": {
        "bookworm": "6.1.148-1",
        "bookworm-security": "6.1.158-1"
      },
      "fixed_version": "6.0.2-1",
      "urgency": "not yet assigned"
    },
    "bullseye": {
      "status": "resolved",
      "repositories": {
        "bullseye": "5.10.223-1",
        "bullseye-security": "5.10.244-1"
      },
      "fixed_version": "5.10.148-1",
      "urgency": "not yet assigned"
    },
    "forky": {
      "status": "resolved",
      "repositories": {
        "forky": "6.16.12-2"
      },
      "fixed_version": "6.0.2-1",
      "urgency": "not yet assigned"
    },
    "sid": {
      "status": "resolved",
      "repositories": {
        "sid": "6.17.7-2"
      },
      "fixed_version": "6.0.2-1",
      "urgency": "not yet assigned"
    },
    "trixie": {
      "status": "resolved",
      "repositories": {
        "trixie": "6.12.43-1",
        "trixie-security": "6.12.48-1"
      },
      "fixed_version": "6.0.2-1",
      "urgency": "not yet assigned"
    }
  }
}