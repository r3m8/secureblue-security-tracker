{
  "description": "In the Linux kernel, the following vulnerability has been resolved:  alloc_tag: allocate percpu counters for module tags dynamically  When a module gets unloaded it checks whether any of its tags are still in use and if so, we keep the memory containing module's allocation tags alive until all tags are unused.  However percpu counters referenced by the tags are freed by free_module().  This will lead to UAF if the memory allocated by a module is accessed after module was unloaded.  To fix this we allocate percpu counters for module allocation tags dynamically and we keep it alive for tags which are still in use after module unloading.  This also removes the requirement of a larger PERCPU_MODULE_RESERVE when memory allocation profiling is enabled because percpu memory for counters does not need to be reserved anymore.",
  "scope": "local",
  "releases": {
    "bookworm": {
      "status": "resolved",
      "repositories": {
        "bookworm": "6.1.148-1",
        "bookworm-security": "6.1.158-1"
      },
      "fixed_version": "0",
      "urgency": "unimportant"
    },
    "bullseye": {
      "status": "resolved",
      "repositories": {
        "bullseye": "5.10.223-1",
        "bullseye-security": "5.10.244-1"
      },
      "fixed_version": "0",
      "urgency": "unimportant"
    },
    "forky": {
      "status": "resolved",
      "repositories": {
        "forky": "6.16.12-2"
      },
      "fixed_version": "0",
      "urgency": "unimportant"
    },
    "sid": {
      "status": "resolved",
      "repositories": {
        "sid": "6.17.7-2"
      },
      "fixed_version": "0",
      "urgency": "unimportant"
    },
    "trixie": {
      "status": "resolved",
      "repositories": {
        "trixie": "6.12.43-1",
        "trixie-security": "6.12.48-1"
      },
      "fixed_version": "0",
      "urgency": "unimportant"
    }
  }
}