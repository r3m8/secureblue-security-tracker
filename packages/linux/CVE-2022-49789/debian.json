{
  "description": "In the Linux kernel, the following vulnerability has been resolved:  scsi: zfcp: Fix double free of FSF request when qdio send fails  We used to use the wrong type of integer in 'zfcp_fsf_req_send()' to cache the FSF request ID when sending a new FSF request. This is used in case the sending fails and we need to remove the request from our internal hash table again (so we don't keep an invalid reference and use it when we free the request again).  In 'zfcp_fsf_req_send()' we used to cache the ID as 'int' (signed and 32 bit wide), but the rest of the zfcp code (and the firmware specification) handles the ID as 'unsigned long'/'u64' (unsigned and 64 bit wide [s390x ELF ABI]).  For one this has the obvious problem that when the ID grows past 32 bit (this can happen reasonably fast) it is truncated to 32 bit when storing it in the cache variable and so doesn't match the original ID anymore.  The second less obvious problem is that even when the original ID has not yet grown past 32 bit, as soon as the 32nd bit is set in the original ID (0x80000000 = 2'147'483'648) we will have a mismatch when we cast it back to 'unsigned long'. As the cached variable is of a signed type, the compiler will choose a sign-extending instruction to load the 32 bit variable into a 64 bit register (e.g.: 'lgf %r11,188(%r15)'). So once we pass the cached variable into 'zfcp_reqlist_find_rm()' to remove the request again all the leading zeros will be flipped to ones to extend the sign and won't match the original ID anymore (this has been observed in practice).  If we can't successfully remove the request from the hash table again after 'zfcp_qdio_send()' fails (this happens regularly when zfcp cannot notify the adapter about new work because the adapter is already gone during e.g. a ChpID toggle) we will end up with a double free.  We unconditionally free the request in the calling function when 'zfcp_fsf_req_send()' fails, but because the request is still in the hash table we end up with a stale memory reference, and once the zfcp adapter is either reset during recovery or shutdown we end up freeing the same memory twice.  The resulting stack traces vary depending on the kernel and have no direct correlation to the place where the bug occurs. Here are three examples that have been seen in practice:    list_del corruption. next->prev should be 00000001b9d13800, but was 00000000dead4ead. (next=00000001bd131a00)   ------------[ cut here ]------------   kernel BUG at lib/list_debug.c:62!   monitor event: 0040 ilc:2 [#1] PREEMPT SMP   Modules linked in: ...   CPU: 9 PID: 1617 Comm: zfcperp0.0.1740 Kdump: loaded   Hardware name: ...   Krnl PSW : 0704d00180000000 00000003cbeea1f8 (__list_del_entry_valid+0x98/0x140)              R:0 T:1 IO:1 EX:1 Key:0 M:1 W:0 P:0 AS:3 CC:1 PM:0 RI:0 EA:3   Krnl GPRS: 00000000916d12f1 0000000080000000 000000000000006d 00000003cb665cd6              0000000000000001 0000000000000000 0000000000000000 00000000d28d21e8              00000000d3844000 00000380099efd28 00000001bd131a00 00000001b9d13800              00000000d3290100 0000000000000000 00000003cbeea1f4 00000380099efc70   Krnl Code: 00000003cbeea1e8: c020004f68a7        larl    %r2,00000003cc8d7336              00000003cbeea1ee: c0e50027fd65        brasl   %r14,00000003cc3e9cb8             #00000003cbeea1f4: af000000            mc      0,0             >00000003cbeea1f8: c02000920440        larl    %r2,00000003cd12aa78              00000003cbeea1fe: c0e500289c25        brasl   %r14,00000003cc3fda48              00000003cbeea204: b9040043            lgr     %r4,%r3              00000003cbeea208: b9040051            lgr     %r5,%r1              00000003cbeea20c: b9040032            lgr     %r3,%r2   Call Trace:    [<00000003cbeea1f8>] __list_del_entry_valid+0x98/0x140   ([<00000003cbeea1f4>] __list_del_entry_valid+0x94/0x140)    [<000003ff7ff502fe>] zfcp_fsf_req_dismiss_all+0xde/0x150 [zfcp]    [<000003ff7ff49cd0>] zfcp_erp_strategy_do_action+0x160/0x280 [zfcp] ---truncated---",
  "scope": "local",
  "releases": {
    "bookworm": {
      "status": "resolved",
      "repositories": {
        "bookworm": "6.1.148-1",
        "bookworm-security": "6.1.158-1"
      },
      "fixed_version": "6.0.10-1",
      "urgency": "not yet assigned"
    },
    "bullseye": {
      "status": "resolved",
      "repositories": {
        "bullseye": "5.10.223-1",
        "bullseye-security": "5.10.244-1"
      },
      "fixed_version": "5.10.158-1",
      "urgency": "not yet assigned"
    },
    "forky": {
      "status": "resolved",
      "repositories": {
        "forky": "6.16.12-2"
      },
      "fixed_version": "6.0.10-1",
      "urgency": "not yet assigned"
    },
    "sid": {
      "status": "resolved",
      "repositories": {
        "sid": "6.17.7-2"
      },
      "fixed_version": "6.0.10-1",
      "urgency": "not yet assigned"
    },
    "trixie": {
      "status": "resolved",
      "repositories": {
        "trixie": "6.12.43-1",
        "trixie-security": "6.12.48-1"
      },
      "fixed_version": "6.0.10-1",
      "urgency": "not yet assigned"
    }
  }
}