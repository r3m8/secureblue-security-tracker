{
  "description": "In the Linux kernel, the following vulnerability has been resolved:  eventpoll: don't decrement ep refcount while still holding the ep mutex  Jann Horn points out that epoll is decrementing the ep refcount and then doing a      mutex_unlock(&ep->mtx);  afterwards. That's very wrong, because it can lead to a use-after-free.  That pattern is actually fine for the very last reference, because the code in question will delay the actual call to \"ep_free(ep)\" until after it has unlocked the mutex.  But it's wrong for the much subtler \"next to last\" case when somebody *else* may also be dropping their reference and free the ep while we're still using the mutex.  Note that this is true even if that other user is also using the same ep mutex: mutexes, unlike spinlocks, can not be used for object ownership, even if they guarantee mutual exclusion.  A mutex \"unlock\" operation is not atomic, and as one user is still accessing the mutex as part of unlocking it, another user can come in and get the now released mutex and free the data structure while the first user is still cleaning up.  See our mutex documentation in Documentation/locking/mutex-design.rst, in particular the section [1] about semantics:  \t\"mutex_unlock() may access the mutex structure even after it has \t internally released the lock already - so it's not safe for \t another context to acquire the mutex and assume that the \t mutex_unlock() context is not using the structure anymore\"  So if we drop our ep ref before the mutex unlock, but we weren't the last one, we may then unlock the mutex, another user comes in, drops _their_ reference and releases the 'ep' as it now has no users - all while the mutex_unlock() is still accessing it.  Fix this by simply moving the ep refcount dropping to outside the mutex: the refcount itself is atomic, and doesn't need mutex protection (that's the whole _point_ of refcounts: unlike mutexes, they are inherently about object lifetimes).",
  "scope": "local",
  "releases": {
    "bookworm": {
      "status": "resolved",
      "repositories": {
        "bookworm": "6.1.148-1",
        "bookworm-security": "6.1.158-1"
      },
      "fixed_version": "0",
      "urgency": "unimportant"
    },
    "bullseye": {
      "status": "resolved",
      "repositories": {
        "bullseye": "5.10.223-1",
        "bullseye-security": "5.10.244-1"
      },
      "fixed_version": "0",
      "urgency": "unimportant"
    },
    "forky": {
      "status": "resolved",
      "repositories": {
        "forky": "6.16.12-2"
      },
      "fixed_version": "6.16.3-1",
      "urgency": "not yet assigned"
    },
    "sid": {
      "status": "resolved",
      "repositories": {
        "sid": "6.17.7-2"
      },
      "fixed_version": "6.16.3-1",
      "urgency": "not yet assigned"
    },
    "trixie": {
      "status": "resolved",
      "repositories": {
        "trixie": "6.12.43-1",
        "trixie-security": "6.12.48-1"
      },
      "fixed_version": "6.12.41-1",
      "urgency": "not yet assigned"
    }
  }
}