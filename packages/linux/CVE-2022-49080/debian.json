{
  "description": "In the Linux kernel, the following vulnerability has been resolved:  mm/mempolicy: fix mpol_new leak in shared_policy_replace  If mpol_new is allocated but not used in restart loop, mpol_new will be freed via mpol_put before returning to the caller.  But refcnt is not initialized yet, so mpol_put could not do the right things and might leak the unused mpol_new.  This would happen if mempolicy was updated on the shared shmem file while the sp->lock has been dropped during the memory allocation.  This issue could be triggered easily with the below code snippet if there are many processes doing the below work at the same time:    shmid = shmget((key_t)5566, 1024 * PAGE_SIZE, 0666|IPC_CREAT);   shm = shmat(shmid, 0, 0);   loop many times {     mbind(shm, 1024 * PAGE_SIZE, MPOL_LOCAL, mask, maxnode, 0);     mbind(shm + 128 * PAGE_SIZE, 128 * PAGE_SIZE, MPOL_DEFAULT, mask,           maxnode, 0);   }",
  "scope": "local",
  "releases": {
    "bookworm": {
      "status": "resolved",
      "repositories": {
        "bookworm": "6.1.148-1",
        "bookworm-security": "6.1.158-1"
      },
      "fixed_version": "5.17.3-1",
      "urgency": "not yet assigned"
    },
    "bullseye": {
      "status": "resolved",
      "repositories": {
        "bullseye": "5.10.223-1",
        "bullseye-security": "5.10.244-1"
      },
      "fixed_version": "5.10.113-1",
      "urgency": "not yet assigned"
    },
    "forky": {
      "status": "resolved",
      "repositories": {
        "forky": "6.16.12-2"
      },
      "fixed_version": "5.17.3-1",
      "urgency": "not yet assigned"
    },
    "sid": {
      "status": "resolved",
      "repositories": {
        "sid": "6.17.7-2"
      },
      "fixed_version": "5.17.3-1",
      "urgency": "not yet assigned"
    },
    "trixie": {
      "status": "resolved",
      "repositories": {
        "trixie": "6.12.43-1",
        "trixie-security": "6.12.48-1"
      },
      "fixed_version": "5.17.3-1",
      "urgency": "not yet assigned"
    }
  }
}