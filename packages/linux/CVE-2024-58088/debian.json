{
  "description": "In the Linux kernel, the following vulnerability has been resolved:  bpf: Fix deadlock when freeing cgroup storage  The following commit bc235cdb423a (\"bpf: Prevent deadlock from recursive bpf_task_storage_[get|delete]\") first introduced deadlock prevention for fentry/fexit programs attaching on bpf_task_storage helpers. That commit also employed the logic in map free path in its v6 version.  Later bpf_cgrp_storage was first introduced in c4bcfb38a95e (\"bpf: Implement cgroup storage available to non-cgroup-attached bpf progs\") which faces the same issue as bpf_task_storage, instead of its busy counter, NULL was passed to bpf_local_storage_map_free() which opened a window to cause deadlock:  \t<TASK> \t\t(acquiring local_storage->lock) \t_raw_spin_lock_irqsave+0x3d/0x50 \tbpf_local_storage_update+0xd1/0x460 \tbpf_cgrp_storage_get+0x109/0x130 \tbpf_prog_a4d4a370ba857314_cgrp_ptr+0x139/0x170 \t? __bpf_prog_enter_recur+0x16/0x80 \tbpf_trampoline_6442485186+0x43/0xa4 \tcgroup_storage_ptr+0x9/0x20 \t\t(holding local_storage->lock) \tbpf_selem_unlink_storage_nolock.constprop.0+0x135/0x160 \tbpf_selem_unlink_storage+0x6f/0x110 \tbpf_local_storage_map_free+0xa2/0x110 \tbpf_map_free_deferred+0x5b/0x90 \tprocess_one_work+0x17c/0x390 \tworker_thread+0x251/0x360 \tkthread+0xd2/0x100 \tret_from_fork+0x34/0x50 \tret_from_fork_asm+0x1a/0x30 \t</TASK>  Progs:  - A: SEC(\"fentry/cgroup_storage_ptr\")    - cgid (BPF_MAP_TYPE_HASH) \tRecord the id of the cgroup the current task belonging \tto in this hash map, using the address of the cgroup \tas the map key.    - cgrpa (BPF_MAP_TYPE_CGRP_STORAGE) \tIf current task is a kworker, lookup the above hash \tmap using function parameter @owner as the key to get \tits corresponding cgroup id which is then used to get \ta trusted pointer to the cgroup through \tbpf_cgroup_from_id(). This trusted pointer can then \tbe passed to bpf_cgrp_storage_get() to finally trigger \tthe deadlock issue.  - B: SEC(\"tp_btf/sys_enter\")    - cgrpb (BPF_MAP_TYPE_CGRP_STORAGE) \tThe only purpose of this prog is to fill Prog A's \thash map by calling bpf_cgrp_storage_get() for as \tmany userspace tasks as possible.  Steps to reproduce:  - Run A;  - while (true) { Run B; Destroy B; }  Fix this issue by passing its busy counter to the free procedure so it can be properly incremented before storage/smap locking.",
  "scope": "local",
  "releases": {
    "bookworm": {
      "status": "resolved",
      "repositories": {
        "bookworm": "6.1.148-1",
        "bookworm-security": "6.1.158-1"
      },
      "fixed_version": "0",
      "urgency": "unimportant"
    },
    "bullseye": {
      "status": "resolved",
      "repositories": {
        "bullseye": "5.10.223-1",
        "bullseye-security": "5.10.244-1"
      },
      "fixed_version": "0",
      "urgency": "unimportant"
    },
    "forky": {
      "status": "resolved",
      "repositories": {
        "forky": "6.16.12-2"
      },
      "fixed_version": "6.12.17-1",
      "urgency": "not yet assigned"
    },
    "sid": {
      "status": "resolved",
      "repositories": {
        "sid": "6.17.7-2"
      },
      "fixed_version": "6.12.17-1",
      "urgency": "not yet assigned"
    },
    "trixie": {
      "status": "resolved",
      "repositories": {
        "trixie": "6.12.43-1",
        "trixie-security": "6.12.48-1"
      },
      "fixed_version": "6.12.17-1",
      "urgency": "not yet assigned"
    }
  }
}