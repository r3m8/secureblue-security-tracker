{
  "description": "In the Linux kernel, the following vulnerability has been resolved:  fs: writeback: fix use-after-free in __mark_inode_dirty()  An use-after-free issue occurred when __mark_inode_dirty() get the bdi_writeback that was in the progress of switching.  CPU: 1 PID: 562 Comm: systemd-random- Not tainted 6.6.56-gb4403bd46a8e #1 ...... pstate: 60400005 (nZCv daif +PAN -UAO -TCO -DIT -SSBS BTYPE=--) pc : __mark_inode_dirty+0x124/0x418 lr : __mark_inode_dirty+0x118/0x418 sp : ffffffc08c9dbbc0 ........ Call trace:  __mark_inode_dirty+0x124/0x418  generic_update_time+0x4c/0x60  file_modified+0xcc/0xd0  ext4_buffered_write_iter+0x58/0x124  ext4_file_write_iter+0x54/0x704  vfs_write+0x1c0/0x308  ksys_write+0x74/0x10c  __arm64_sys_write+0x1c/0x28  invoke_syscall+0x48/0x114  el0_svc_common.constprop.0+0xc0/0xe0  do_el0_svc+0x1c/0x28  el0_svc+0x40/0xe4  el0t_64_sync_handler+0x120/0x12c  el0t_64_sync+0x194/0x198  Root cause is:  systemd-random-seed                         kworker ---------------------------------------------------------------------- ___mark_inode_dirty                     inode_switch_wbs_work_fn    spin_lock(&inode->i_lock);   inode_attach_wb   locked_inode_to_wb_and_lock_list      get inode->i_wb      spin_unlock(&inode->i_lock);      spin_lock(&wb->list_lock)   spin_lock(&inode->i_lock)   inode_io_list_move_locked   spin_unlock(&wb->list_lock)   spin_unlock(&inode->i_lock)                                     spin_lock(&old_wb->list_lock)                                       inode_do_switch_wbs                                         spin_lock(&inode->i_lock)                                         inode->i_wb = new_wb                                         spin_unlock(&inode->i_lock)                                     spin_unlock(&old_wb->list_lock)                                     wb_put_many(old_wb, nr_switched)                                       cgwb_release                                       old wb released   wb_wakeup_delayed() accesses wb,   then trigger the use-after-free   issue  Fix this race condition by holding inode spinlock until wb_wakeup_delayed() finished.",
  "scope": "local",
  "releases": {
    "bookworm": {
      "status": "resolved",
      "repositories": {
        "bookworm": "6.1.148-1",
        "bookworm-security": "6.1.158-1"
      },
      "fixed_version": "6.1.153-1",
      "urgency": "not yet assigned"
    },
    "bullseye": {
      "status": "open",
      "repositories": {
        "bullseye": "5.10.223-1",
        "bullseye-security": "5.10.244-1"
      },
      "urgency": "not yet assigned"
    },
    "forky": {
      "status": "resolved",
      "repositories": {
        "forky": "6.16.12-2"
      },
      "fixed_version": "6.16.6-1",
      "urgency": "not yet assigned"
    },
    "sid": {
      "status": "resolved",
      "repositories": {
        "sid": "6.17.7-2"
      },
      "fixed_version": "6.16.6-1",
      "urgency": "not yet assigned"
    },
    "trixie": {
      "status": "resolved",
      "repositories": {
        "trixie": "6.12.43-1",
        "trixie-security": "6.12.48-1"
      },
      "fixed_version": "6.12.48-1",
      "urgency": "not yet assigned"
    }
  }
}