{
  "description": "In the Linux kernel, the following vulnerability has been resolved:  r6040: Fix kmemleak in probe and remove  There is a memory leaks reported by kmemleak:    unreferenced object 0xffff888116111000 (size 2048):     comm \"modprobe\", pid 817, jiffies 4294759745 (age 76.502s)     hex dump (first 32 bytes):       00 c4 0a 04 81 88 ff ff 08 10 11 16 81 88 ff ff  ................       08 10 11 16 81 88 ff ff 00 00 00 00 00 00 00 00  ................     backtrace:       [<ffffffff815bcd82>] kmalloc_trace+0x22/0x60       [<ffffffff827e20ee>] phy_device_create+0x4e/0x90       [<ffffffff827e6072>] get_phy_device+0xd2/0x220       [<ffffffff827e7844>] mdiobus_scan+0xa4/0x2e0       [<ffffffff827e8be2>] __mdiobus_register+0x482/0x8b0       [<ffffffffa01f5d24>] r6040_init_one+0x714/0xd2c [r6040]       ...  The problem occurs in probe process as follows:   r6040_init_one:     mdiobus_register       mdiobus_scan    <- alloc and register phy_device,                          the reference count of phy_device is 3     r6040_mii_probe       phy_connect     <- connect to the first phy_device,                          so the reference count of the first                          phy_device is 4, others are 3     register_netdev   <- fault inject succeeded, goto error handling path      // error handling path     err_out_mdio_unregister:       mdiobus_unregister(lp->mii_bus);     err_out_mdio:       mdiobus_free(lp->mii_bus);    <- the reference count of the first                                        phy_device is 1, it is not released                                        and other phy_devices are released   // similarly, the remove process also has the same problem  The root cause is traced to the phy_device is not disconnected when removes one r6040 device in r6040_remove_one() or on error handling path after r6040_mii probed successfully. In r6040_mii_probe(), a net ethernet device is connected to the first PHY device of mii_bus, in order to notify the connected driver when the link status changes, which is the default behavior of the PHY infrastructure to handle everything. Therefore the phy_device should be disconnected when removes one r6040 device or on error handling path.  Fix it by adding phy_disconnect() when removes one r6040 device or on error handling path after r6040_mii probed successfully.",
  "scope": "local",
  "releases": {
    "bookworm": {
      "status": "resolved",
      "repositories": {
        "bookworm": "6.1.148-1",
        "bookworm-security": "6.1.158-1"
      },
      "fixed_version": "6.1.4-1",
      "urgency": "not yet assigned"
    },
    "bullseye": {
      "status": "resolved",
      "repositories": {
        "bullseye": "5.10.223-1",
        "bullseye-security": "5.10.244-1"
      },
      "fixed_version": "5.10.178-1",
      "urgency": "not yet assigned"
    },
    "forky": {
      "status": "resolved",
      "repositories": {
        "forky": "6.16.12-2"
      },
      "fixed_version": "6.1.4-1",
      "urgency": "not yet assigned"
    },
    "sid": {
      "status": "resolved",
      "repositories": {
        "sid": "6.17.7-2"
      },
      "fixed_version": "6.1.4-1",
      "urgency": "not yet assigned"
    },
    "trixie": {
      "status": "resolved",
      "repositories": {
        "trixie": "6.12.43-1",
        "trixie-security": "6.12.48-1"
      },
      "fixed_version": "6.1.4-1",
      "urgency": "not yet assigned"
    }
  }
}