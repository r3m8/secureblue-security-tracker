{
  "description": "In the Linux kernel, the following vulnerability has been resolved:  bpf: Don't use tnum_range on array range checking for poke descriptors  Hsin-Wei reported a KASAN splat triggered by their BPF runtime fuzzer which is based on a customized syzkaller:    BUG: KASAN: slab-out-of-bounds in bpf_int_jit_compile+0x1257/0x13f0   Read of size 8 at addr ffff888004e90b58 by task syz-executor.0/1489   CPU: 1 PID: 1489 Comm: syz-executor.0 Not tainted 5.19.0 #1   Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS   1.13.0-1ubuntu1.1 04/01/2014   Call Trace:    <TASK>    dump_stack_lvl+0x9c/0xc9    print_address_description.constprop.0+0x1f/0x1f0    ? bpf_int_jit_compile+0x1257/0x13f0    kasan_report.cold+0xeb/0x197    ? kvmalloc_node+0x170/0x200    ? bpf_int_jit_compile+0x1257/0x13f0    bpf_int_jit_compile+0x1257/0x13f0    ? arch_prepare_bpf_dispatcher+0xd0/0xd0    ? rcu_read_lock_sched_held+0x43/0x70    bpf_prog_select_runtime+0x3e8/0x640    ? bpf_obj_name_cpy+0x149/0x1b0    bpf_prog_load+0x102f/0x2220    ? __bpf_prog_put.constprop.0+0x220/0x220    ? find_held_lock+0x2c/0x110    ? __might_fault+0xd6/0x180    ? lock_downgrade+0x6e0/0x6e0    ? lock_is_held_type+0xa6/0x120    ? __might_fault+0x147/0x180    __sys_bpf+0x137b/0x6070    ? bpf_perf_link_attach+0x530/0x530    ? new_sync_read+0x600/0x600    ? __fget_files+0x255/0x450    ? lock_downgrade+0x6e0/0x6e0    ? fput+0x30/0x1a0    ? ksys_write+0x1a8/0x260    __x64_sys_bpf+0x7a/0xc0    ? syscall_enter_from_user_mode+0x21/0x70    do_syscall_64+0x3b/0x90    entry_SYSCALL_64_after_hwframe+0x63/0xcd   RIP: 0033:0x7f917c4e2c2d  The problem here is that a range of tnum_range(0, map->max_entries - 1) has limited ability to represent the concrete tight range with the tnum as the set of resulting states from value + mask can result in a superset of the actual intended range, and as such a tnum_in(range, reg->var_off) check may yield true when it shouldn't, for example tnum_range(0, 2) would result in 00XX -> v = 0000, m = 0011 such that the intended set of {0, 1, 2} is here represented by a less precise superset of {0, 1, 2, 3}. As the register is known const scalar, really just use the concrete reg->var_off.value for the upper index check.",
  "scope": "local",
  "releases": {
    "bookworm": {
      "status": "resolved",
      "repositories": {
        "bookworm": "6.1.148-1",
        "bookworm-security": "6.1.158-1"
      },
      "fixed_version": "6.0.2-1",
      "urgency": "not yet assigned"
    },
    "bullseye": {
      "status": "resolved",
      "repositories": {
        "bullseye": "5.10.223-1",
        "bullseye-security": "5.10.244-1"
      },
      "fixed_version": "5.10.140-1",
      "urgency": "not yet assigned"
    },
    "forky": {
      "status": "resolved",
      "repositories": {
        "forky": "6.16.12-2"
      },
      "fixed_version": "6.0.2-1",
      "urgency": "not yet assigned"
    },
    "sid": {
      "status": "resolved",
      "repositories": {
        "sid": "6.17.7-2"
      },
      "fixed_version": "6.0.2-1",
      "urgency": "not yet assigned"
    },
    "trixie": {
      "status": "resolved",
      "repositories": {
        "trixie": "6.12.43-1",
        "trixie-security": "6.12.48-1"
      },
      "fixed_version": "6.0.2-1",
      "urgency": "not yet assigned"
    }
  }
}