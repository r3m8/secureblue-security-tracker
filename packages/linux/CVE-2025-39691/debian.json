{
  "description": "In the Linux kernel, the following vulnerability has been resolved:  fs/buffer: fix use-after-free when call bh_read() helper  There's issue as follows: BUG: KASAN: stack-out-of-bounds in end_buffer_read_sync+0xe3/0x110 Read of size 8 at addr ffffc9000168f7f8 by task swapper/3/0 CPU: 3 UID: 0 PID: 0 Comm: swapper/3 Not tainted 6.16.0-862.14.0.6.x86_64 Hardware name: QEMU Standard PC (i440FX + PIIX, 1996) Call Trace:  <IRQ>  dump_stack_lvl+0x55/0x70  print_address_description.constprop.0+0x2c/0x390  print_report+0xb4/0x270  kasan_report+0xb8/0xf0  end_buffer_read_sync+0xe3/0x110  end_bio_bh_io_sync+0x56/0x80  blk_update_request+0x30a/0x720  scsi_end_request+0x51/0x2b0  scsi_io_completion+0xe3/0x480  ? scsi_device_unbusy+0x11e/0x160  blk_complete_reqs+0x7b/0x90  handle_softirqs+0xef/0x370  irq_exit_rcu+0xa5/0xd0  sysvec_apic_timer_interrupt+0x6e/0x90  </IRQ>   Above issue happens when do ntfs3 filesystem mount, issue may happens  as follows:            mount                            IRQ ntfs_fill_super   read_cache_page     do_read_cache_folio       filemap_read_folio         mpage_read_folio \t do_mpage_readpage \t  ntfs_get_block_vbo \t   bh_read \t     submit_bh \t     wait_on_buffer(bh); \t                            blk_complete_reqs \t\t\t\t     scsi_io_completion \t\t\t\t      scsi_end_request \t\t\t\t       blk_update_request \t\t\t\t        end_bio_bh_io_sync \t\t\t\t\t end_buffer_read_sync \t\t\t\t\t  __end_buffer_read_notouch \t\t\t\t\t   unlock_buffer              wait_on_buffer(bh);--> return will return to caller  \t\t\t\t\t  put_bh \t\t\t\t\t    --> trigger stack-out-of-bounds In the mpage_read_folio() function, the stack variable 'map_bh' is passed to ntfs_get_block_vbo(). Once unlock_buffer() unlocks and wait_on_buffer() returns to continue processing, the stack variable is likely to be reclaimed. Consequently, during the end_buffer_read_sync() process, calling put_bh() may result in stack overrun.  If the bh is not allocated on the stack, it belongs to a folio.  Freeing a buffer head which belongs to a folio is done by drop_buffers() which will fail to free buffers which are still locked.  So it is safe to call put_bh() before __end_buffer_read_notouch().",
  "scope": "local",
  "releases": {
    "bookworm": {
      "status": "resolved",
      "repositories": {
        "bookworm": "6.1.148-1",
        "bookworm-security": "6.1.158-1"
      },
      "fixed_version": "6.1.153-1",
      "urgency": "not yet assigned"
    },
    "bullseye": {
      "status": "resolved",
      "repositories": {
        "bullseye": "5.10.223-1",
        "bullseye-security": "5.10.244-1"
      },
      "fixed_version": "5.10.244-1",
      "urgency": "not yet assigned"
    },
    "forky": {
      "status": "resolved",
      "repositories": {
        "forky": "6.16.12-2"
      },
      "fixed_version": "6.16.5-1",
      "urgency": "not yet assigned"
    },
    "sid": {
      "status": "resolved",
      "repositories": {
        "sid": "6.17.7-2"
      },
      "fixed_version": "6.16.5-1",
      "urgency": "not yet assigned"
    },
    "trixie": {
      "status": "resolved",
      "repositories": {
        "trixie": "6.12.43-1",
        "trixie-security": "6.12.48-1"
      },
      "fixed_version": "6.12.48-1",
      "urgency": "not yet assigned"
    }
  }
}