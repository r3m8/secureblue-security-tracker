{
  "description": "In the Linux kernel, the following vulnerability has been resolved:  can: mcba_usb: populate ndo_change_mtu() to prevent buffer overflow  Sending an PF_PACKET allows to bypass the CAN framework logic and to directly reach the xmit() function of a CAN driver. The only check which is performed by the PF_PACKET framework is to make sure that skb->len fits the interface's MTU.  Unfortunately, because the mcba_usb driver does not populate its net_device_ops->ndo_change_mtu(), it is possible for an attacker to configure an invalid MTU by doing, for example:    $ ip link set can0 mtu 9999  After doing so, the attacker could open a PF_PACKET socket using the ETH_P_CANXL protocol:  \tsocket(PF_PACKET, SOCK_RAW, htons(ETH_P_CANXL))  to inject a malicious CAN XL frames. For example:  \tstruct canxl_frame frame = { \t\t.flags = 0xff, \t\t.len = 2048, \t};  The CAN drivers' xmit() function are calling can_dev_dropped_skb() to check that the skb is valid, unfortunately under above conditions, the malicious packet is able to go through can_dev_dropped_skb() checks:    1. the skb->protocol is set to ETH_P_CANXL which is valid (the      function does not check the actual device capabilities).    2. the length is a valid CAN XL length.  And so, mcba_usb_start_xmit() receives a CAN XL frame which it is not able to correctly handle and will thus misinterpret it as a CAN frame.  This can result in a buffer overflow. The driver will consume cf->len as-is with no further checks on these lines:  \tusb_msg.dlc = cf->len;  \tmemcpy(usb_msg.data, cf->data, usb_msg.dlc);  Here, cf->len corresponds to the flags field of the CAN XL frame. In our previous example, we set canxl_frame->flags to 0xff. Because the maximum expected length is 8, a buffer overflow of 247 bytes occurs!  Populate net_device_ops->ndo_change_mtu() to ensure that the interface's MTU can not be set to anything bigger than CAN_MTU. By fixing the root cause, this prevents the buffer overflow.",
  "scope": "local",
  "releases": {
    "bookworm": {
      "status": "resolved",
      "repositories": {
        "bookworm": "6.1.148-1",
        "bookworm-security": "6.1.158-1"
      },
      "fixed_version": "6.1.158-1",
      "urgency": "not yet assigned"
    },
    "bullseye": {
      "status": "open",
      "repositories": {
        "bullseye": "5.10.223-1",
        "bullseye-security": "5.10.244-1"
      },
      "urgency": "not yet assigned"
    },
    "forky": {
      "status": "resolved",
      "repositories": {
        "forky": "6.16.12-2"
      },
      "fixed_version": "6.16.10-1",
      "urgency": "not yet assigned"
    },
    "sid": {
      "status": "resolved",
      "repositories": {
        "sid": "6.17.7-2"
      },
      "fixed_version": "6.16.10-1",
      "urgency": "not yet assigned"
    },
    "trixie": {
      "status": "open",
      "repositories": {
        "trixie": "6.12.43-1",
        "trixie-security": "6.12.48-1"
      },
      "urgency": "not yet assigned"
    }
  }
}