{
  "description": "In the Linux kernel, the following vulnerability has been resolved:  mm/ptdump: take the memory hotplug lock inside ptdump_walk_pgd()  Memory hot remove unmaps and tears down various kernel page table regions as required.  The ptdump code can race with concurrent modifications of the kernel page tables.  When leaf entries are modified concurrently, the dump code may log stale or inconsistent information for a VA range, but this is otherwise not harmful.  But when intermediate levels of kernel page table are freed, the dump code will continue to use memory that has been freed and potentially reallocated for another purpose.  In such cases, the ptdump code may dereference bogus addresses, leading to a number of potential problems.  To avoid the above mentioned race condition, platforms such as arm64, riscv and s390 take memory hotplug lock, while dumping kernel page table via the sysfs interface /sys/kernel/debug/kernel_page_tables.  Similar race condition exists while checking for pages that might have been marked W+X via /sys/kernel/debug/kernel_page_tables/check_wx_pages which in turn calls ptdump_check_wx().  Instead of solving this race condition again, let's just move the memory hotplug lock inside generic ptdump_check_wx() which will benefit both the scenarios.  Drop get_online_mems() and put_online_mems() combination from all existing platform ptdump code paths.",
  "scope": "local",
  "releases": {
    "bullseye": {
      "status": "resolved",
      "repositories": {
        "bullseye-security": "6.1.153-1~deb11u1"
      },
      "fixed_version": "6.1.153-1~deb11u1",
      "urgency": "not yet assigned"
    }
  }
}