{
  "description": "In the Linux kernel, the following vulnerability has been resolved:  efivarfs: Fix slab-out-of-bounds in efivarfs_d_compare  Observed on kernel 6.6 (present on master as well):    BUG: KASAN: slab-out-of-bounds in memcmp+0x98/0xd0   Call trace:    kasan_check_range+0xe8/0x190    __asan_loadN+0x1c/0x28    memcmp+0x98/0xd0    efivarfs_d_compare+0x68/0xd8    __d_lookup_rcu_op_compare+0x178/0x218    __d_lookup_rcu+0x1f8/0x228    d_alloc_parallel+0x150/0x648    lookup_open.isra.0+0x5f0/0x8d0    open_last_lookups+0x264/0x828    path_openat+0x130/0x3f8    do_filp_open+0x114/0x248    do_sys_openat2+0x340/0x3c0    __arm64_sys_openat+0x120/0x1a0  If dentry->d_name.len < EFI_VARIABLE_GUID_LEN , 'guid' can become negative, leadings to oob. The issue can be triggered by parallel lookups using invalid filename:    T1\t\t\tT2   lookup_open    ->lookup     simple_lookup      d_add      // invalid dentry is added to hash list  \t\t\tlookup_open \t\t\t d_alloc_parallel \t\t\t  __d_lookup_rcu \t\t\t   __d_lookup_rcu_op_compare \t\t\t    hlist_bl_for_each_entry_rcu \t\t\t    // invalid dentry can be retrieved \t\t\t     ->d_compare \t\t\t      efivarfs_d_compare \t\t\t      // oob  Fix it by checking 'guid' before cmp.",
  "scope": "local",
  "releases": {
    "bullseye": {
      "status": "resolved",
      "repositories": {
        "bullseye-security": "6.1.153-1~deb11u1"
      },
      "fixed_version": "6.1.153-1~deb11u1",
      "urgency": "not yet assigned"
    }
  }
}