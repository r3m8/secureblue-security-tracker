{
  "description": "In the Linux kernel, the following vulnerability has been resolved:  regulator: max20086: fix invalid memory access  max20086_parse_regulators_dt() calls of_regulator_match() using an array of struct of_regulator_match allocated on the stack for the matches argument.  of_regulator_match() calls devm_of_regulator_put_matches(), which calls devres_alloc() to allocate a struct devm_of_regulator_matches which will be de-allocated using devm_of_regulator_put_matches().  struct devm_of_regulator_matches is populated with the stack allocated matches array.  If the device fails to probe, devm_of_regulator_put_matches() will be called and will try to call of_node_put() on that stack pointer, generating the following dmesg entries:  max20086 6-0028: Failed to read DEVICE_ID reg: -121 kobject: '\\xc0$\\xa5\\x03' (000000002cebcb7a): is not initialized, yet kobject_put() is being called.  Followed by a stack trace matching the call flow described above.  Switch to allocating the matches array using devm_kcalloc() to avoid accessing the stack pointer long after it's out of scope.  This also has the advantage of allowing multiple max20086 to probe without overriding the data stored inside the global of_regulator_match.",
  "scope": "local",
  "releases": {
    "bullseye": {
      "status": "resolved",
      "repositories": {
        "bullseye-security": "6.1.153-1~deb11u1"
      },
      "fixed_version": "6.1.140-1~deb11u1",
      "urgency": "not yet assigned"
    }
  }
}