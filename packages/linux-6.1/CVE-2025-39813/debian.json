{
  "description": "In the Linux kernel, the following vulnerability has been resolved:  ftrace: Fix potential warning in trace_printk_seq during ftrace_dump  When calling ftrace_dump_one() concurrently with reading trace_pipe, a WARN_ON_ONCE() in trace_printk_seq() can be triggered due to a race condition.  The issue occurs because:  CPU0 (ftrace_dump)                              CPU1 (reader) echo z > /proc/sysrq-trigger  !trace_empty(&iter) trace_iterator_reset(&iter) <- len = size = 0                                                 cat /sys/kernel/tracing/trace_pipe trace_find_next_entry_inc(&iter)   __find_next_entry     ring_buffer_empty_cpu <- all empty   return NULL  trace_printk_seq(&iter.seq)   WARN_ON_ONCE(s->seq.len >= s->seq.size)  In the context between trace_empty() and trace_find_next_entry_inc() during ftrace_dump, the ring buffer data was consumed by other readers. This caused trace_find_next_entry_inc to return NULL, failing to populate `iter.seq`. At this point, due to the prior trace_iterator_reset, both `iter.seq.len` and `iter.seq.size` were set to 0. Since they are equal, the WARN_ON_ONCE condition is triggered.  Move the trace_printk_seq() into the if block that checks to make sure the return value of trace_find_next_entry_inc() is non-NULL in ftrace_dump_one(), ensuring the 'iter.seq' is properly populated before subsequent operations.",
  "scope": "local",
  "releases": {
    "bullseye": {
      "status": "resolved",
      "repositories": {
        "bullseye-security": "6.1.153-1~deb11u1"
      },
      "fixed_version": "6.1.153-1~deb11u1",
      "urgency": "not yet assigned"
    }
  }
}