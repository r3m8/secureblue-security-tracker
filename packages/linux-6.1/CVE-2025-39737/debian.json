{
  "description": "In the Linux kernel, the following vulnerability has been resolved:  mm/kmemleak: avoid soft lockup in __kmemleak_do_cleanup()  A soft lockup warning was observed on a relative small system x86-64 system with 16 GB of memory when running a debug kernel with kmemleak enabled.    watchdog: BUG: soft lockup - CPU#8 stuck for 33s! [kworker/8:1:134]  The test system was running a workload with hot unplug happening in parallel.  Then kemleak decided to disable itself due to its inability to allocate more kmemleak objects.  The debug kernel has its CONFIG_DEBUG_KMEMLEAK_MEM_POOL_SIZE set to 40,000.  The soft lockup happened in kmemleak_do_cleanup() when the existing kmemleak objects were being removed and deleted one-by-one in a loop via a workqueue.  In this particular case, there are at least 40,000 objects that need to be processed and given the slowness of a debug kernel and the fact that a raw_spinlock has to be acquired and released in __delete_object(), it could take a while to properly handle all these objects.  As kmemleak has been disabled in this case, the object removal and deletion process can be further optimized as locking isn't really needed.  However, it is probably not worth the effort to optimize for such an edge case that should rarely happen.  So the simple solution is to call cond_resched() at periodic interval in the iteration loop to avoid soft lockup.",
  "scope": "local",
  "releases": {
    "bullseye": {
      "status": "resolved",
      "repositories": {
        "bullseye-security": "6.1.153-1~deb11u1"
      },
      "fixed_version": "6.1.153-1~deb11u1",
      "urgency": "not yet assigned"
    }
  }
}