{
  "description": "In the Linux kernel, the following vulnerability has been resolved:  smb: client: fix use-after-free in cifs_oplock_break  A race condition can occur in cifs_oplock_break() leading to a use-after-free of the cinode structure when unmounting:    cifs_oplock_break()     _cifsFileInfo_put(cfile)       cifsFileInfo_put_final()         cifs_sb_deactive()           [last ref, start releasing sb]             kill_sb()               kill_anon_super()                 generic_shutdown_super()                   evict_inodes()                     dispose_list()                       evict()                         destroy_inode()                           call_rcu(&inode->i_rcu, i_callback)     spin_lock(&cinode->open_file_lock)  <- OK                             [later] i_callback()                               cifs_free_inode()                                 kmem_cache_free(cinode)     spin_unlock(&cinode->open_file_lock)  <- UAF     cifs_done_oplock_break(cinode)       <- UAF  The issue occurs when umount has already released its reference to the superblock. When _cifsFileInfo_put() calls cifs_sb_deactive(), this releases the last reference, triggering the immediate cleanup of all inodes under RCU. However, cifs_oplock_break() continues to access the cinode after this point, resulting in use-after-free.  Fix this by holding an extra reference to the superblock during the entire oplock break operation. This ensures that the superblock and its inodes remain valid until the oplock break completes.",
  "scope": "local",
  "releases": {
    "bullseye": {
      "status": "resolved",
      "repositories": {
        "bullseye-security": "6.1.153-1~deb11u1"
      },
      "fixed_version": "6.1.153-1~deb11u1",
      "urgency": "not yet assigned"
    }
  }
}